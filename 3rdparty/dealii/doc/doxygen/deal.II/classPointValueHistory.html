<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The deal.II Library: PointValueHistory&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="http://www.dealii.org/deal.ico"></link>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2014 by the deal.II authors"></meta>
<meta name="deal.II-version" content="8.1.0"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classPointValueHistory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PointValueHistory&lt; dim &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6dafec5dc4ea3c9becf3f15ba8109efd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a6dafec5dc4ea3c9becf3f15ba8109efd">PointValueHistory</a> (const unsigned <a class="el" href="classint.html">int</a> n_independent_variables=0)</td></tr>
<tr class="separator:a6dafec5dc4ea3c9becf3f15ba8109efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc82dc305d2e15f8734a424ce3794ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a0bc82dc305d2e15f8734a424ce3794ae">PointValueHistory</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;<a class="el" href="classPointValueHistory.html#af485d86f52fdde36582dd2f234b3a4ed">dof_handler</a>, const unsigned <a class="el" href="classint.html">int</a> n_independent_variables=0)</td></tr>
<tr class="separator:a0bc82dc305d2e15f8734a424ce3794ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5111181a2b59663807743e693151766f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a5111181a2b59663807743e693151766f">PointValueHistory</a> (const <a class="el" href="classPointValueHistory.html">PointValueHistory</a> &amp;point_value_history)</td></tr>
<tr class="separator:a5111181a2b59663807743e693151766f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c9af3b568b3d8f23addb9049bf53a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPointValueHistory.html">PointValueHistory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a67c9af3b568b3d8f23addb9049bf53a2">operator=</a> (const <a class="el" href="classPointValueHistory.html">PointValueHistory</a> &amp;point_value_history)</td></tr>
<tr class="separator:a67c9af3b568b3d8f23addb9049bf53a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac004576a9c7f0cc5b96c11cd5206db7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#aac004576a9c7f0cc5b96c11cd5206db7">~PointValueHistory</a> ()</td></tr>
<tr class="separator:aac004576a9c7f0cc5b96c11cd5206db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3b629b8c92b7e3e0f76a8b07321b66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a0a3b629b8c92b7e3e0f76a8b07321b66">add_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;location)</td></tr>
<tr class="separator:a0a3b629b8c92b7e3e0f76a8b07321b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23e84a472cd39ff443be4adf287d62b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#aa23e84a472cd39ff443be4adf287d62b">add_points</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;locations)</td></tr>
<tr class="separator:aa23e84a472cd39ff443be4adf287d62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031374cd3a6b7554ce41045f4c9a3a61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a031374cd3a6b7554ce41045f4c9a3a61">add_field_name</a> (const std::string &amp;vector_name, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="classPointValueHistory.html#a0cd025298f40579e3f537e5b3f681437">component_mask</a>=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a031374cd3a6b7554ce41045f4c9a3a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb50d456f51d6733a7e0eb0744c9636"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#aebb50d456f51d6733a7e0eb0744c9636">add_field_name</a> (const std::string &amp;vector_name, const unsigned <a class="el" href="classint.html">int</a> n_components)</td></tr>
<tr class="separator:aebb50d456f51d6733a7e0eb0744c9636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802794b179fa312ccb58a3d04ff4cb66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a802794b179fa312ccb58a3d04ff4cb66">add_component_names</a> (const std::string &amp;vector_name, const std::vector&lt; std::string &gt; &amp;component_names)</td></tr>
<tr class="separator:a802794b179fa312ccb58a3d04ff4cb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6476b08396849430eb60e70b5a101d26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a6476b08396849430eb60e70b5a101d26">add_independent_names</a> (const std::vector&lt; std::string &gt; &amp;independent_names)</td></tr>
<tr class="separator:a6476b08396849430eb60e70b5a101d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f3a63e25f0129b4a10dda6b05ea11f"><td class="memTemplParams" colspan="2">template&lt;class VECTOR &gt; </td></tr>
<tr class="memitem:a68f3a63e25f0129b4a10dda6b05ea11f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a68f3a63e25f0129b4a10dda6b05ea11f">evaluate_field</a> (const std::string &amp;name, const VECTOR &amp;solution)</td></tr>
<tr class="separator:a68f3a63e25f0129b4a10dda6b05ea11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5356595aa5538902d3e12801b2c0690"><td class="memTemplParams" colspan="2">template&lt;class VECTOR &gt; </td></tr>
<tr class="memitem:ae5356595aa5538902d3e12801b2c0690"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#ae5356595aa5538902d3e12801b2c0690">evaluate_field</a> (const std::vector&lt; std::string &gt; &amp;names, const VECTOR &amp;solution, const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt; &amp;data_postprocessor, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature)</td></tr>
<tr class="separator:ae5356595aa5538902d3e12801b2c0690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177aaa62687c754dd52d8d8811a00f0c"><td class="memTemplParams" colspan="2">template&lt;class VECTOR &gt; </td></tr>
<tr class="memitem:a177aaa62687c754dd52d8d8811a00f0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a177aaa62687c754dd52d8d8811a00f0c">evaluate_field</a> (const std::string &amp;name, const VECTOR &amp;solution, const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt; &amp;data_postprocessor, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature)</td></tr>
<tr class="separator:a177aaa62687c754dd52d8d8811a00f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384bc2dcce65610b83412c57b8a0036f"><td class="memTemplParams" colspan="2">template&lt;class VECTOR &gt; </td></tr>
<tr class="memitem:a384bc2dcce65610b83412c57b8a0036f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a384bc2dcce65610b83412c57b8a0036f">evaluate_field_at_requested_location</a> (const std::string &amp;name, const VECTOR &amp;solution)</td></tr>
<tr class="separator:a384bc2dcce65610b83412c57b8a0036f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98865baea0ffbea26e1448ace38cdd82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a98865baea0ffbea26e1448ace38cdd82">start_new_dataset</a> (const <a class="el" href="classdouble.html">double</a> key)</td></tr>
<tr class="separator:a98865baea0ffbea26e1448ace38cdd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96df36261c0c1791c3d8f746198b864"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#ad96df36261c0c1791c3d8f746198b864">push_back_independent</a> (const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;<a class="el" href="classPointValueHistory.html#af75a1541f1c03f99568c1c612786392b">independent_values</a>)</td></tr>
<tr class="separator:ad96df36261c0c1791c3d8f746198b864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2e435fa514282d5d85997a113b302b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#abc2e435fa514282d5d85997a113b302b">write_gnuplot</a> (const std::string &amp;base_name, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; postprocessor_locations=std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;())</td></tr>
<tr class="separator:abc2e435fa514282d5d85997a113b302b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0e74fc80898e40bd59a0621d0205a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a9e0e74fc80898e40bd59a0621d0205a9">mark_support_locations</a> ()</td></tr>
<tr class="separator:a9e0e74fc80898e40bd59a0621d0205a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cbf1bf2087d5c28c02dab55d667805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a59cbf1bf2087d5c28c02dab55d667805">mark_locations</a> () <a class="el" href="group__Sparsity.html#ga0849dabf81f46d4d964e251c286784dd">DEAL_II_DEPRECATED</a></td></tr>
<tr class="separator:a59cbf1bf2087d5c28c02dab55d667805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792606db223d2e373d9ed15ed799bda4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a792606db223d2e373d9ed15ed799bda4">get_support_locations</a> (std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt; &amp;locations)</td></tr>
<tr class="separator:a792606db223d2e373d9ed15ed799bda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104318a44d6f35b94b9be6f6f37abb4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a104318a44d6f35b94b9be6f6f37abb4c">get_points</a> (std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt; &amp;locations)</td></tr>
<tr class="separator:a104318a44d6f35b94b9be6f6f37abb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05f0349bace88ec0f5959c8e4951a0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#ae05f0349bace88ec0f5959c8e4951a0e">get_postprocessor_locations</a> (const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;locations)</td></tr>
<tr class="separator:ae05f0349bace88ec0f5959c8e4951a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70942e59366c981f81ff3bb7ff800f00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a70942e59366c981f81ff3bb7ff800f00">close</a> ()</td></tr>
<tr class="separator:a70942e59366c981f81ff3bb7ff800f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0507c065ea2e3ea03001032986948c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a5b0507c065ea2e3ea03001032986948c">clear</a> ()</td></tr>
<tr class="separator:a5b0507c065ea2e3ea03001032986948c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640364a55562b95453a7add1aff0c94c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a640364a55562b95453a7add1aff0c94c">status</a> (std::ostream &amp;out)</td></tr>
<tr class="separator:a640364a55562b95453a7add1aff0c94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86aee1b8b5011475aeae56071a6fe3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#ae86aee1b8b5011475aeae56071a6fe3b">deep_check</a> (const <a class="el" href="classbool.html">bool</a> strict)</td></tr>
<tr class="separator:ae86aee1b8b5011475aeae56071a6fe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38552860ce1d683a94b68fd17e7bebba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a38552860ce1d683a94b68fd17e7bebba">DeclException0</a> (ExcNoIndependent)</td></tr>
<tr class="separator:a38552860ce1d683a94b68fd17e7bebba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6128c8a95542dd997fae1161eae4279"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#aa6128c8a95542dd997fae1161eae4279">DeclException0</a> (ExcDataLostSync)</td></tr>
<tr class="separator:aa6128c8a95542dd997fae1161eae4279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922e6b167741353de774549794c256d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a922e6b167741353de774549794c256d9">DeclException0</a> (ExcDoFHandlerRequired)</td></tr>
<tr class="separator:a922e6b167741353de774549794c256d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d88aacf16e8deb42c0d73d58024177"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a30d88aacf16e8deb42c0d73d58024177">DeclException0</a> (ExcDoFHandlerChanged)</td></tr>
<tr class="separator:a30d88aacf16e8deb42c0d73d58024177"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae0be238effe81ad3ba1d208e7b4a296c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#ae0be238effe81ad3ba1d208e7b4a296c">tria_change_listener</a> ()</td></tr>
<tr class="separator:ae0be238effe81ad3ba1d208e7b4a296c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a570646e2cfd2d62da8ad4629fa93a0e8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a570646e2cfd2d62da8ad4629fa93a0e8">dataset_key</a></td></tr>
<tr class="separator:a570646e2cfd2d62da8ad4629fa93a0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75a1541f1c03f99568c1c612786392b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#af75a1541f1c03f99568c1c612786392b">independent_values</a></td></tr>
<tr class="separator:af75a1541f1c03f99568c1c612786392b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5285098c0a506b75b06764655a1fc213"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a5285098c0a506b75b06764655a1fc213">indep_names</a></td></tr>
<tr class="separator:a5285098c0a506b75b06764655a1fc213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08c8fa63521606b24b62a1507696631"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#ad08c8fa63521606b24b62a1507696631">data_store</a></td></tr>
<tr class="separator:ad08c8fa63521606b24b62a1507696631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd025298f40579e3f537e5b3f681437"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="classComponentMask.html">ComponentMask</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a0cd025298f40579e3f537e5b3f681437">component_mask</a></td></tr>
<tr class="separator:a0cd025298f40579e3f537e5b3f681437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ade8228a9f5b1453e0ccbac8b77b47"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a17ade8228a9f5b1453e0ccbac8b77b47">component_names_map</a></td></tr>
<tr class="separator:a17ade8228a9f5b1453e0ccbac8b77b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1881e8d5a696fde31276f0922120aef"><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; <a class="el" href="classinternal_1_1PointValueHistory_1_1PointGeometryData.html">internal::PointValueHistory::PointGeometryData</a><br class="typebreak"/>
&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#ab1881e8d5a696fde31276f0922120aef">point_geometry_data</a></td></tr>
<tr class="separator:ab1881e8d5a696fde31276f0922120aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594bf6fb299eea7a02c02e0110f7b364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a594bf6fb299eea7a02c02e0110f7b364">closed</a></td></tr>
<tr class="separator:a594bf6fb299eea7a02c02e0110f7b364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad455c0548900585db9704b42ef171064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#ad455c0548900585db9704b42ef171064">cleared</a></td></tr>
<tr class="separator:ad455c0548900585db9704b42ef171064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af485d86f52fdde36582dd2f234b3a4ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a><br class="typebreak"/>
&lt; dim &gt;, <a class="el" href="classPointValueHistory.html">PointValueHistory</a><br class="typebreak"/>
&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#af485d86f52fdde36582dd2f234b3a4ed">dof_handler</a></td></tr>
<tr class="separator:af485d86f52fdde36582dd2f234b3a4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537f2f55c0262a43c1bcbb05060040c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a537f2f55c0262a43c1bcbb05060040c7">triangulation_changed</a></td></tr>
<tr class="separator:a537f2f55c0262a43c1bcbb05060040c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b771a2b3e7fe3114cd4843170f84a70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a3b771a2b3e7fe3114cd4843170f84a70">have_dof_handler</a></td></tr>
<tr class="separator:a3b771a2b3e7fe3114cd4843170f84a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0973b92f7a50cb794a864b6754c0e3bd"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a0973b92f7a50cb794a864b6754c0e3bd">tria_listener</a></td></tr>
<tr class="separator:a0973b92f7a50cb794a864b6754c0e3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d541e5f545746f35840454139fea674"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointValueHistory.html#a0d541e5f545746f35840454139fea674">n_indep</a></td></tr>
<tr class="separator:a0d541e5f545746f35840454139fea674"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim&gt;<br/>
class PointValueHistory&lt; dim &gt;</h3>

<p><a class="el" href="classPointValueHistory.html">PointValueHistory</a> tackles the overhead of plotting time (or any other iterative process) graphs of solution values at specific points on the mesh. The user specifies the points which the solution should be monitored at ahead of time, as well as giving each solution vector that they want to record a mnemonic name. Then, for each step the user calls one of the three available "evaluate field" methods to store the data from each time step, and the class extracts data for the requested points to store it. Finally, once the computation is finished, the user can request output files to be generated; these files are in Gnuplot format but are basically just regular text and can easily be imported into other programs well, for example into spreadsheets.</p>
<p>The user can store extra variables which do not relate to mesh location specifying n_independent_variables. The class then expects a std::vector of size n_independent_variables to be added during each step using the method <code>push_back_independent</code>. This may be used for example for recording external input, logging solver performance data such as time taken to solve the step and solver steps before convergence, saving norms calculated, or simply saving the time, number of time step, or number of nonlinear iteration along with the data evaluated from the mesh.</p>
<p>The three "evaluate field" methods each have different strengths and weaknesses making each suitable for different contexts: </p>
<ol>
<li>
<p class="startli">Firstly, the <code>evaluate_field</code> version that does not take a <code><a class="el" href="classDataPostprocessor.html">DataPostprocessor</a></code> object selects the nearest support point (see <a class="el" href="DEALGlossary.html#GlossSupport">this entry in the glossary</a>) to a given point to extract data from. This makes the code that needs to be run at each time step very short, since looping over the mesh to extract the needed dof_index can be done just once at the start. However, this method is not suitable for <a class="el" href="classFiniteElement.html">FiniteElement</a> objects that do not assign dofs to actual mesh locations (i.e. FEs without <a class="el" href="DEALGlossary.html#GlossSupport">support points</a>) or if adaptive mesh refinement is used. The reason for the latter restriction is that the location of the closest support point to a given point may change upon mesh refinement. The class will throw an exception if any change to the triangulation is made (Although the nearest support point could be re-computed upon mesh refinement, the location of the support point will most likely change slightly, making the interpretation of the data difficult, hence this is not implemented currently.)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Secondly, <code>evaluate_field_at_requested_location</code> calls <code><a class="el" href="namespaceVectorTools.html#a52246ae4d0c5669917030ef5f209074f">VectorTools::point_value</a></code> to compute values at the specific point requested. This method is valid for any FE that is supported by <code><a class="el" href="namespaceVectorTools.html#a52246ae4d0c5669917030ef5f209074f">VectorTools::point_value</a></code>. Specifically, this method can be called by codes using adaptive mesh refinement.</p>
<p class="endli"></p>
</li>
<li>
Finally, the class offers a function <code>evaluate_field</code> that takes a <code><a class="el" href="classDataPostprocessor.html">DataPostprocessor</a></code> object. This method allows the deal.II data postprocessor to be used to compute new quantities from the solution on the fly. The values are located at the nearest quadrature point to the requested point. If the mesh is refined between calls, this point will change, so care must be taken when using this method in code using adaptive refinement, but as the output will be meaningful (in the sense that the quadrature point selected is guaranteed to remain in the same vicinity, the class does not prevent the use of this method in adaptive codes. The class provides warnings in the output files if the mesh has changed. Note that one can reduce the error this procedure introduces by providing a quadrature formula that has more points, at the expense of performing more work since then the closest quadrature points is nearer to the point at which the evaluation is really supposed to happen. (As a sidenote: Why not do the evaluation at the requested point right away? The reason for this is that it would require setting up a new quadrature point object on each cell that has only a single point corresponding to the reference coordinates of the point you really want; then initializing a <a class="el" href="classFEValues.html">FEValues</a> object with it; then evaluating the solution at this point; then handing the result to the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> object. This sequence of things is expensive &ndash; which is the reason why <a class="el" href="namespaceVectorTools.html#a52246ae4d0c5669917030ef5f209074f">VectorTools::point_value()</a> is expensive. Using the same quadrature formula on each cell on which we want to evaluate the solution and only having to initialize a FEValue object once is a much cheaper alternative, albeit of course at the expense of getting only an approximate result.) </li>
</ol>
<p>When recording a new mnemonic name, the user must supply a component_mask (see <a class="el" href="DEALGlossary.html#GlossComponentMask">this glossary entry</a>) to indicate the <a class="el" href="DEALGlossary.html#GlossComponent">(vector) components</a> to be extracted from the given input. If the user simply wants to extract all the components, the mask need not be explicitly supplied to the <code>add_field_name</code> method and the default value of the parameter is sufficient. If the <code>evaluate_field</code> with a <code><a class="el" href="classDataPostprocessor.html">DataPostprocessor</a></code> object is used, the component_mask is interpreted as the mask of the <code><a class="el" href="classDataPostprocessor.html">DataPostprocessor</a></code> return vector. The size of this mask can be different to that of the FE space, but must be provided when the <code>add_field_name</code> method is called. One variant of the <code>add_field_name</code> method allows an unsigned int input to construct a suitable mask, if all values from the <code><a class="el" href="classDataPostprocessor.html">DataPostprocessor</a></code> are desired.</p>
<p>The class automatically generates names for the data stored based on the mnemonics supplied. The methods <code>add_component_names</code> and <code>add_independent_names</code> allow the user to provide lists of names to use instead if desired.</p>
<p>Following is a little code snippet that shows a common usage of this class:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/point_value_history.h&gt;</span></div>
<div class="line"><span class="comment">//....</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//... code to setup Triangulation, perform any refinement necessary</span></div>
<div class="line"><span class="comment">// and setup DoFHandler, sizing solution Vectors etc</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// call the constructor</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_inputs = 1; <span class="comment">// just one independent value, which happens to be an input</span></div>
<div class="line"><a class="code" href="classPointValueHistory.html">PointValueHistory&lt;dim&gt;</a> node_monitor(<a class="code" href="classPointValueHistory.html#af485d86f52fdde36582dd2f234b3a4ed">dof_handler</a>, n_inputs);</div>
<div class="line"></div>
<div class="line"><span class="comment">// setup fields and points required</span></div>
<div class="line">node_monitor.add_field_name(<span class="stringliteral">&quot;Solution&quot;</span>);</div>
<div class="line">std::vector &lt;Point &lt;dim&gt; &gt; point_vector(2);</div>
<div class="line">point_vector[0] = <a class="code" href="classPoint.html">Point &lt;dim&gt;</a>(0, 0);</div>
<div class="line">point_vector[1] = <a class="code" href="classPoint.html">Point &lt;dim&gt;</a>(0.25, 0);</div>
<div class="line">node_monitor.add_points(point_vector); <span class="comment">// multiple points at once</span></div>
<div class="line">node_monitor.add_point(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(1, 0.2)); <span class="comment">// add a single point</span></div>
<div class="line">node_monitor.close(); <span class="comment">// close the class once the setup is complete</span></div>
<div class="line">node_monitor.status(std::cout); <span class="comment">// print out status to check if desired</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// ... more code ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// ... in an iterative loop ...</span></div>
<div class="line"><span class="comment">// double time, vector &lt;double&gt; with size 1 input_value,</span></div>
<div class="line"><span class="comment">// and Vector &lt;double&gt; solution calculated in the loop</span></div>
<div class="line">node_monitor.start_new_dataset(time);</div>
<div class="line">node_monitor.push_back_independent(input_value);</div>
<div class="line">node_monitor.evaluate_field(<span class="stringliteral">&quot;Solution&quot;</span>, solution);</div>
<div class="line"></div>
<div class="line"><span class="comment">// ... end of iterative loop ...</span></div>
<div class="line"></div>
<div class="line">node_monitor.write_gnuplot(<span class="stringliteral">&quot;node&quot;</span>); <span class="comment">// write out data files</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00208">208</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6dafec5dc4ea3c9becf3f15ba8109efd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::<a class="el" href="classPointValueHistory.html">PointValueHistory</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_independent_variables</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide a stripped down instance of the class which does not support adding points or mesh data. This may be used for example for recording external input or logging solver performance data. </p>

</div>
</div>
<a class="anchor" id="a0bc82dc305d2e15f8734a424ce3794ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::<a class="el" href="classPointValueHistory.html">PointValueHistory</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_independent_variables</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor linking the class to a specific <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code>. This class reads specific data from the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> and stores it internally for quick access (in particular dof indices of closest neighbors to requested points) the class is fairly intolerant to changes to the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> if data at support points is required. Mesh refinement and <code><a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a></code> methods should be performed before the <code>add_points</code> method is called and adaptive grid refinement is only supported by some methods.</p>
<p>The user can store extra variables which do not relate to mesh location by specifying the number required using n_independent_variables and making calls to <code>push_back_independent</code> as needed. This may be used for example for recording external input or logging solver performance data. </p>

</div>
</div>
<a class="anchor" id="a5111181a2b59663807743e693151766f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::<a class="el" href="classPointValueHistory.html">PointValueHistory</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_value_history</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. This constructor can be safely called with a <code><a class="el" href="classPointValueHistory.html">PointValueHistory</a></code> object that contains data, but this could be expensive and should be avoided. </p>

</div>
</div>
<a class="anchor" id="aac004576a9c7f0cc5b96c11cd5206db7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::~<a class="el" href="classPointValueHistory.html">PointValueHistory</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deconstructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a67c9af3b568b3d8f23addb9049bf53a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPointValueHistory.html">PointValueHistory</a>&amp; <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_value_history</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator. This assignment operator can be safely called once the class is closed and data added, but this is provided primarily to allow a <code><a class="el" href="classPointValueHistory.html">PointValueHistory</a></code> object declared in a class to be reinitialized later in the class. Using the assignment operator when the object contains data could be expensive. </p>

</div>
</div>
<a class="anchor" id="a0a3b629b8c92b7e3e0f76a8b07321b66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::add_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a single point to the class. The support points (one per component) in the mesh that are closest to that point are found and their details stored for use when <code>evaluate_field</code> is called. If more than one point is required rather use the <code>add_points</code> method since this minimizes iterations over the mesh. </p>

</div>
</div>
<a class="anchor" id="aa23e84a472cd39ff443be4adf287d62b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::add_points </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>locations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add multiple points to the class. The support points (one per component) in the mesh that are closest to that point is found and their details stored for use when <code>evaluate_field</code> is called. If more than one point is required, rather call this method as it is more efficient than the add_point method since it minimizes iterations over the mesh. The points are added to the internal database in the order they appear in the list and there is always a one to one correspondence between the requested point and the added point, even if a point is requested multiple times. </p>

</div>
</div>
<a class="anchor" id="a031374cd3a6b7554ce41045f4c9a3a61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::add_field_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vector_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put another mnemonic string (and hence <code>VECTOR</code>) into the class. This method adds storage space for variables equal to the number of true values in component_mask. This also adds extra entries for points that are already in the class, so <code>add_field_name</code> and <code>add_points</code> can be called in any order. </p>

</div>
</div>
<a class="anchor" id="aebb50d456f51d6733a7e0eb0744c9636"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::add_field_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vector_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put another mnemonic string (and hence <code>VECTOR</code>) into the class. This method adds storage space for n_components variables. This also adds extra entries for points that are already in the class, so <code>add_field_name</code> and <code>add_points</code> can be called in any order. This method generates a std::vector 0, ..., n_components-1 and calls the previous function. </p>

</div>
</div>
<a class="anchor" id="a802794b179fa312ccb58a3d04ff4cb66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::add_component_names </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vector_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide optional names for each component of a field. These names will be used instead of names generated from the field name, if supplied. </p>

</div>
</div>
<a class="anchor" id="a6476b08396849430eb60e70b5a101d26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::add_independent_names </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>independent_names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide optional names for the independent values. These names will be used instead of "Indep_...", if supplied. </p>

</div>
</div>
<a class="anchor" id="a68f3a63e25f0129b4a10dda6b05ea11f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;class VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::evaluate_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract values at the stored points from the VECTOR supplied and add them to the new dataset in vector_name. The component mask supplied when the field was added is used to select components to extract. If a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> is used, one (and only one) evaluate_field method must be called for each dataset (time step, iteration, etc) for each vector_name, otherwise a <code>ExcDataLostSync</code> error can occur. </p>

</div>
</div>
<a class="anchor" id="ae5356595aa5538902d3e12801b2c0690"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;class VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::evaluate_field </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_postprocessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute values using a <code><a class="el" href="classDataPostprocessor.html">DataPostprocessor</a></code> object with the <code>VECTOR</code> supplied and add them to the new dataset in vector_name. The component_mask supplied when the field was added is used to select components to extract from the <code><a class="el" href="classDataPostprocessor.html">DataPostprocessor</a></code> return vector. This method takes a vector of field names to process and is preferred if many fields use the same <code><a class="el" href="classDataPostprocessor.html">DataPostprocessor</a></code> object as each cell is only located once. The quadrature object supplied is used for all components of a vector field. Although this method will not throw an exception if the mesh has changed. (No internal data structures are invalidated as the quadrature points are repicked each time the function is called.) Nevertheless the user must be aware that if the mesh changes the point selected will also vary slightly, making interpretation of the data more difficult. If a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> is used, one (and only one) evaluate_field method must be called for each dataset (time step, iteration, etc) for each vector_name, otherwise a <code>ExcDataLostSync</code> error can occur. </p>

</div>
</div>
<a class="anchor" id="a177aaa62687c754dd52d8d8811a00f0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;class VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::evaluate_field </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_postprocessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a std::vector &lt;std::string&gt; containing only vector_name and call the above function. The above function is more efficient if multiple fields use the same <code><a class="el" href="classDataPostprocessor.html">DataPostprocessor</a></code> object. </p>

</div>
</div>
<a class="anchor" id="a384bc2dcce65610b83412c57b8a0036f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;class VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::evaluate_field_at_requested_location </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract values at the points actually requested from the VECTOR supplied and add them to the new dataset in vector_name. Unlike the other evaluate_field methods this method does not care if the dof_handler has been modified because it uses calls to <code><a class="el" href="namespaceVectorTools.html#a52246ae4d0c5669917030ef5f209074f">VectorTools::point_value</a></code> to extract there data. Therefore, if only this method is used, the class is fully compatible with adaptive refinement. The component_mask supplied when the field was added is used to select components to extract. If a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> is used, one (and only one) evaluate_field method must be called for each dataset (time step, iteration, etc) for each vector_name, otherwise a <code>ExcDataLostSync</code> error can occur. </p>

</div>
</div>
<a class="anchor" id="a98865baea0ffbea26e1448ace38cdd82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::start_new_dataset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the key for the current dataset to the dataset. Although calling this method first is sensible, the order in which this method, <code>evaluate_field</code> and <code>push_back_independent</code> is not important. It is however important that all the data for a give dataset is added to each dataset and that it is added before a new data set is started. This prevents a <code>ExcDataLostSync</code>. </p>

</div>
</div>
<a class="anchor" id="ad96df36261c0c1791c3d8f746198b864"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::push_back_independent </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>independent_values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If independent values have been set up, this method stores these values. This should only be called once per dataset, and if independent values are used it must be called for every dataset. A <code>ExcDataLostSync</code> exception can be thrown if this method is not called. </p>

</div>
</div>
<a class="anchor" id="abc2e435fa514282d5d85997a113b302b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::write_gnuplot </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td>
          <td class="paramname"><em>postprocessor_locations</em> = <code>std::vector&lt;&#160;<a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write out a series of .gpl files named base_name + "-00.gpl", base_name + "-01.gpl" etc. The data file gives info about where the support points selected and interpreting the data. If <code>n_indep</code> != 0 an additional file base_name + "_indep.gpl" containing key and independent data. The file name agrees with the order the points were added to the class. The names of the data columns can be supplied using the functions <code>add_component_names</code> and <code>add_independent_names</code>. The support point information is only meaningful if the dof_handler has not been changed. Therefore, if adaptive mesh refinement has been used the support point data should not be used. The optional parameter postprocessor_locations is used to add the postprocessor locations to the output files. If this is desired, the data should be obtained from a call to get_postprocessor_locations while the dof_handler is usable. The default parameter is an empty vector of strings, and will suppress postprocessor locations output. </p>

</div>
</div>
<a class="anchor" id="a9e0e74fc80898e40bd59a0621d0205a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::mark_support_locations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a <code><a class="el" href="classVector.html">Vector</a></code> with the indices of selected points flagged with a 1. This method is mainly for testing and verifying that the class is working correctly. By passing this vector to a <a class="el" href="classDataOut.html">DataOut</a> object, the user can verify that the positions returned by <code><a class="el" href="classPointValueHistory.html#a104318a44d6f35b94b9be6f6f37abb4c">PointValueHistory&lt; dim &gt;::get_points</a></code> agree with the positions that <code><a class="el" href="classDataOut.html">DataOut</a></code> interprets from the <code><a class="el" href="classVector.html">Vector</a></code> returned. The code snippet below demonstrates how this could be done: </p>
<div class="fragment"><div class="line"><span class="comment">// Make a DataOut object and attach the dof_handler</span></div>
<div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a5e63bad650805ce93cd74c6dc3b29b11">attach_dof_handler</a>(<a class="code" href="classPointValueHistory.html#af485d86f52fdde36582dd2f234b3a4ed">dof_handler</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Call the mark_locations method to get the vector with indices flagged</span></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> support_point_locations = node_monitor.mark_locations();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add the vector to the data_out object and write out a file in the usual way</span></div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a59a6b70a4b909e0229a20487dd68cc43">add_data_vector</a>(support_point_locations, <span class="stringliteral">&quot;Monitor_Locations&quot;</span>);</div>
<div class="line">data_out.<a class="code" href="classDataOut.html#ab3d44201acb97fba286a897452236b51">build_patches</a>(2);</div>
<div class="line">std::ofstream output(<span class="stringliteral">&quot;locations.gpl&quot;</span>);</div>
<div class="line">data_out.<a class="code" href="classDataOutInterface.html#a471d836d307c6e888ab3b5ad81fe0416">write_gnuplot</a>(output);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a59cbf1bf2087d5c28c02dab55d667805"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::mark_locations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Depreciated:</p>
<p>This function only exists for backward compatibility as this is the interface provided by previous versions of the library. The function mark_support_locations replaces it and reflects the fact that the locations marked are actually the support points.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000175">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a792606db223d2e373d9ed15ed799bda4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::get_support_locations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>locations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the actual location of each support point selected by the <code>add_point(s)</code> method. This can be used to compare with the point requested, for example by using the <code><a class="el" href="classPoint.html#a86ca72325acf82eb9a0bcf61fa5aeb3e">Point&lt;dim&gt;::distance</a></code> function. For convenience, location is resized to the correct number of points by the method. </p>

</div>
</div>
<a class="anchor" id="a104318a44d6f35b94b9be6f6f37abb4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::get_points </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>locations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Depreciated:</p>
<p>This function only exists for backward compatibility as this is the interface provided by previous versions of the library. The function get_support_locations replaces it and reflects the fact that the points returned are actually the support points. </p>

</div>
</div>
<a class="anchor" id="ae05f0349bace88ec0f5959c8e4951a0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::get_postprocessor_locations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>locations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the actual location of the points used by the data_postprocessor. This can be used to compare with the points requested, for example by using the <code><a class="el" href="classPoint.html#a86ca72325acf82eb9a0bcf61fa5aeb3e">Point&lt;dim&gt;::distance</a></code> function. Unlike the support_locations, these locations are computed every time the evaluate_field method is called with a postprocessor. This method uses the same algorithm so can will find the same points. For convenience, location is resized to the correct number of points by the method. </p>

</div>
</div>
<a class="anchor" id="a70942e59366c981f81ff3bb7ff800f00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Once datasets have been added to the class, requests to add additional points will make the data interpretation unclear. The boolean <code>closed</code> defines a state of the class and ensures this does not happen. Additional points or vectors can only be added while the class is not closed, and the class must be closed before datasets can be added or written to file. <code><a class="el" href="classPointValueHistory.html#a104318a44d6f35b94b9be6f6f37abb4c">PointValueHistory::get_points</a></code> and <code><a class="el" href="classPointValueHistory.html#a640364a55562b95453a7add1aff0c94c">PointValueHistory::status</a></code> do not require the class to be closed. If a method that requires a class to be open or close is called while in the wrong state a <code>ExcInvalidState</code> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a5b0507c065ea2e3ea03001032986948c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete the lock this object has to the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> used the last time the class was created. This method should not normally need to be called, but can be useful to ensure that the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> is released before it goes out of scope if the <code><a class="el" href="classPointValueHistory.html">PointValueHistory</a></code> class might live longer than it. Once this method has been called, the majority of methods will throw a <code>ExcInvalidState</code> exception, so if used this method should be the last call to the class. </p>

</div>
</div>
<a class="anchor" id="a640364a55562b95453a7add1aff0c94c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::status </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print useful debugging information about the class, include details about which support points were selected for each point and sizes of the data stored. </p>

</div>
</div>
<a class="anchor" id="ae86aee1b8b5011475aeae56071a6fe3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::deep_check </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>strict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check the internal data sizes to test for a loss of data sync. This is often used in <code>Assert</code> statements with the <code>ExcDataLostSync</code> exception. If <code>strict</code> is <code>false</code> this method returns <code>true</code> if all sizes are within 1 of each other (needed to allow data to be added), with <code>strict</code> = <code>true</code> they must be exactly equal. </p>

</div>
</div>
<a class="anchor" id="a38552860ce1d683a94b68fd17e7bebba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcNoIndependent&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A call has been made to <code>push_back_independent</code> when no independent values were requested. </p>

</div>
</div>
<a class="anchor" id="aa6128c8a95542dd997fae1161eae4279"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcDataLostSync&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This error is thrown to indicate that the data sets appear to be out of sync. The class requires that the number of dataset keys is the same as the number of independent values sets and mesh linked value sets. The number of each of these is allowed to differ by one to allow new values to be added with out restricting the order the user choses to do so. Special cases of no <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> and no independent values should not trigger this error. </p>

</div>
</div>
<a class="anchor" id="a922e6b167741353de774549794c256d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcDoFHandlerRequired&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method which requires access to a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> to be meaningful has been called when <code>have_dof_handler</code> is false (most likely due to default constructor being called). Only independent variables may be logged with no <a class="el" href="classDoFHandler.html">DoFHandler</a>. </p>

</div>
</div>
<a class="anchor" id="a30d88aacf16e8deb42c0d73d58024177"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcDoFHandlerChanged&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The triangulation indicated that mesh has been refined in some way. This suggests that the internal dof indices stored are no longer meaningful. </p>

</div>
</div>
<a class="anchor" id="ae0be238effe81ad3ba1d208e7b4a296c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::tria_change_listener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that will be triggered through signals whenever the triangulation is modified.</p>
<p>It is currently used to check if the triangulation has changed, invalidating precomputed values. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a570646e2cfd2d62da8ad4629fa93a0e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::dataset_key</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores keys, values on the abscissa. This will often be time, but possibly time step, iteration etc. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00722">722</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<a class="anchor" id="af75a1541f1c03f99568c1c612786392b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector &lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::independent_values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Values that do not depend on grid location. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00728">728</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5285098c0a506b75b06764655a1fc213"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::indep_names</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves a vector listing component names associated with a independent_values. This will be an empty vector if the user does not supplies names. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00736">736</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad08c8fa63521606b24b62a1507696631"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector &lt;std::vector &lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; &gt; <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::data_store</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves data for each mnemonic entry. data_store: mnemonic -&gt; [point_0_components point_1_components ... point_n-1_components][key] This format facilitates scalar mnemonics in a vector space, because scalar mnemonics will only have one component per point. <a class="el" href="classVector.html">Vector</a> components are strictly FE.n_components () long. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00749">749</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0cd025298f40579e3f537e5b3f681437"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="classComponentMask.html">ComponentMask</a>&gt; <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::component_mask</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves a component mask for each mnemonic. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00755">755</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<a class="anchor" id="a17ade8228a9f5b1453e0ccbac8b77b47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::component_names_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves a vector listing component names associated with a mnemonic. This will be an empty vector if the user does not supplies names. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00764">764</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab1881e8d5a696fde31276f0922120aef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classinternal_1_1PointValueHistory_1_1PointGeometryData.html">internal::PointValueHistory::PointGeometryData</a> &lt;dim&gt; &gt; <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::point_geometry_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves the location and other mesh info about support points. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00771">771</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<a class="anchor" id="a594bf6fb299eea7a02c02e0110f7b364"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::closed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to enforce <code>closed</code> state for some methods. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00778">778</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad455c0548900585db9704b42ef171064"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::cleared</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to enforce <code>!cleared</code> state for some methods. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00784">784</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<a class="anchor" id="af485d86f52fdde36582dd2f234b3a4ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;,<a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt;dim&gt; &gt; <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::dof_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A smart pointer to the dof_handler supplied to the constructor. This can be released by calling <code><a class="el" href="classPointValueHistory.html#a5b0507c065ea2e3ea03001032986948c">clear()</a></code>. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00792">792</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<a class="anchor" id="a537f2f55c0262a43c1bcbb05060040c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::triangulation_changed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variable to check if the triangulation has changed. If it has changed, certain data is out of date (especially the PointGeometryData::solution_indices. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00801">801</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3b771a2b3e7fe3114cd4843170f84a70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::have_dof_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A boolean to record whether the class was initialized with a <a class="el" href="classDoFHandler.html">DoFHandler</a> or not. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00807">807</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0973b92f7a50cb794a864b6754c0e3bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::tria_listener</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to detect signals from the <a class="el" href="classTriangulation.html">Triangulation</a>. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00812">812</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d541e5f545746f35840454139fea674"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classPointValueHistory.html">PointValueHistory</a>&lt; dim &gt;::n_indep</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the number of independent variables requested. </p>

<p>Definition at line <a class="el" href="point__value__history_8h_source.html#l00818">818</a> of file <a class="el" href="point__value__history_8h_source.html">point_value_history.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/numerics/<a class="el" href="point__value__history_8h_source.html">point_value_history.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 27 2014 15:27:20 for The deal.II Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
